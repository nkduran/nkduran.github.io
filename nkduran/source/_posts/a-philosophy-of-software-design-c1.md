---
title: 软件设计的哲学（二）
date: 2020-02-03 20:29:21
tags:
 - 软件设计
---

> 翻译自[《A Philosophy of Software Design》](https://book.douban.com/subject/30218046/)，作者[John Ousterhout](https://en.wikipedia.org/wiki/John_Ousterhout)，Tcl脚本语言和Tk工具库的发明人。

## <center>第一章 简介</center>

&emsp;&emsp;编写计算机软件是人类历史上最纯粹的创造性活动之一。程序员不会被物理定律一类现实的约束所限，而能够用现实世界中不存在的行为来创造令人兴奋的虚拟世界。编程不像跳芭蕾舞或者打篮球那样需要突出的运动能力和身体协调能力，唯一需要的就是创新的思想，以及对思维的组织能力。如果你能想象出一个系统，就有可能通过一个计算机程序来实现它。

&emsp;&emsp;这意味着，在编写软件方面，最大的限制就是我们对所创建系统的理解能力。程序在逐步发展中，获得的特性越来越多，所包含的组件间会出现很多微妙的依赖关系，本身变得越来越复杂。随着时间的推移，复杂性逐步积累，而对于程序员来讲，在修改系统的时候，把所有相关因素都考虑到变得越来越困难。这些因素拖慢了开发速度，引入了很多问题，而这些问题又反过来进一步地让开发变得更慢，同时增大了成本。复杂性的增长在所有程序的生命周期里都是无可避免的。程序越大，参与其中的人越多，对复杂性的管理就越困难。

&emsp;&emsp;好的开发工具能帮助我们处理复杂性的问题，最近几十年里很多优秀的工具被创造出来，但是我们单独利用工具所做的毕竟有限。如果我们想让编写软件变得更简单，从而能够用更低的成本创建出更强大的系统，我们就必须找出能让软件更简单的方法。虽然在倾尽努力的情况下，复杂性仍然会随时间增加，但是更简单的设计可以让我们在复杂性失控之前，就创建出更大规模和更强大的系统来。

&emsp;&emsp;和复杂性对抗有两类常用的方法，本书会针对这两类方法进行讨论。第一类方法是通过让代码更简单和更清晰来消除复杂性。比如通过消除特殊情况或者使用统一风格的标识符来降低复杂性。

&emsp;&emsp;第二类方法是将复杂性进行封装，从而让程序员在系统上工作的时候，该系统的复杂性不会一下子暴露出来。这类方法常被称为***模块化设计***。在模块化设计中，一个软件系统会被分解为若干模块，就像面向对象语言中的“类”。这些模块设计成彼此相对独立，以便让程序员在不了解其他模块细节的前提下，能够很好的处理当前模块。

&emsp;&emsp;因为软件的延展性，软件设计是一个跨越软件系统整个生命周期的持续的过程。这会让软件设计与其他物理系统——像建筑、轮船、桥梁等——的设计有所不同。然而业界对软件设计的态度并不是向来如此的。在编程历史的很长一段时间内，像其他工程学科一样，设计更集中在项目的开始。这种方式的极端情况被称为***瀑布模型***。根据这个模型，一个项目会被分割成独立的几个阶段，如需求定义、设计、编码、测试和维护等。在瀑布模型中，每个阶段完成后，下个阶段才开始。很多情况下，不同人负责不同阶段。在设计阶段，会针对整个系统进行设计。而在该阶段的末尾，整个设计会被冻结。随后的阶段仅是对该设计充实细节和完成实现。

&emsp;&emsp;不幸地是，对软件而言，瀑布模型很少能运转良好。软件系统本质上要比物理系统更复杂。想要在构建所有东西之前，对大型软件系统的设计做足够好的分析，从而理解它的所有含义是不可能的。随之而来的结果是初始设计会包含很多问题，并且这些问题在落地实现顺利进行之前并不会显露出来。而当发现问题时，瀑布模型并不能很好的支持对主要设计的修改（比如说，设计者可能已经转到另外的项目）。因此，开发者只能试着在不改变整个设计的前提下针对问题打补丁，从而导致复杂性的爆发。

&emsp;&emsp;由于这些原因，在今天大多数的软件开发项目都会使用一些增量方法，比如***敏捷开发***。在敏捷开发中，初始设计聚焦在整个功能集合的一个小的子集。这个功能子集会先被设计，实现和评估。等初始设计中的问题被发现和修正后，更多的新特性会再引入到这个迭代过程——被设计，实现和评估。每次迭代针对现有设计都会暴露一些问题，而这些问题会在下个阶段的新特性设计之前被解决掉。以这种方式展开设计，可以在系统仍然很小的时候就解决掉初始设计中的问题。而后期特性的开发则会受益于早期特性实现过程中获得的经验，问题会更少。

&emsp;&emsp;这种增量方法适用于软件是因为软件具有足够的延展性，从而允许在实现过程中进行重大的设计变更。与此相反，对于物理系统而言，主要设计如果变更的话，挑战就会大很多。比如在施工中期要更改支持一座桥梁的桥塔数量就不切实际。

&emsp;&emsp;增量开发意味着软件设计永远不会完成。设计会贯穿系统的整个生命周期：开发者应该要一直思考关于设计的问题。另外增量开发还意味着不断的重新设计。一个系统或者组件的初始设计永远不会是最好的那个，而过程经验必然能带来更好的做事方法。做为一个软件开发者，应该利用一切机会去改进所开发系统的设计，并计划出一部分时间来做改进设计的工作。

&emsp;&emsp;如果软件开发者需要一直关注设计的问题，而减少复杂性又是软件设计里最重要的一部分，那软件开发者就必须要一直关注软件的复杂性。这本书正是讲有关如何利用复杂性去引导软件整个生命周期内的设计的。

&emsp;&emsp;这本书有两个总体目标。第一个目标是描述软件复杂性的本质：“复杂性”意味着什么？为什么它很重要？如何识别一个程序何时具有必要的复杂性？本书的第二个目标更具有挑战性，介绍一些可以用于在软件开发过程中降低复杂性的技术。不幸地是，没有一个简单的秘诀可以得到优秀的软件设计。相反地，我会介绍一组接近哲学的高级概念，类似于“class应该是深的”，或者“定义不存在的错误”。这些概念可能不会马上让你得到最佳设计，但是利用它们你能够对设计方案进行评估比较，并指导你对设计世界进行探索。

### 1.1 如何使用这本书

&emsp;&emsp;本书中描述的许多设计原则都稍微有些抽象，如果不参考具体代码理解起来会有些难度。但想要找到合适的范例代码——小到足够包含在本书中，大到足够阐述真实系统的问题——实在是个挑战（如果你遇到了好的范例代码，请发给我）。因为这个原因，本书可能无法提供足够的范例，让读者领会如何应用这些原则。

&emsp;&emsp;使用本书最好的方法是在代码评审的时候阅读。在你阅读其他人的代码时，可以思考一下这些代码是否符合书中讨论的概念，而这些概念又如何与代码复杂性关联的。通过其他人的而不是自己的代码来研究设计问题会更容易些。你可以用小红旗标出问题并提出改进意见。另外代码评审还会让你了解新的设计方法和编程技术。

&emsp;&emsp;改进设计技能最好的方法之一就是学会识别这些***小红旗***：那些比实际需要实现地更复杂的代码片段。通观本书我会指出和每个主要设计问题相关的问题，最重要的问题会在书的末尾做个总结。当你在编码的时候有可能会用到这些：当你看到一个小红旗，停下来去找到一种解决问题的替代设计。当你第一次尝试这个方法时，可能要尝试好几个替代方案才能解决，不要轻易地放弃：你在解决问题前尝试地越多，你学到的就会越多。随着时间的积累，你会发现你代码中的小红旗会越来越少，你的设计也会越来越干净。而你积累的经验也会让你发现其他小红旗，以识别出其他设计问题。（我非常乐意听到这些）

&emsp;&emsp;在应用本书的一些方法时，谨慎和适度使用是非常重要的。每一个规则都有针对它的例外情况，每一个原则也有它的局限。如果你把任何一个设计理念推向极端，你可能就会陷入一个糟糕的境地。漂亮的设计呈现地是相互竞争的思想与方法间的一种平衡。书中有几个章节的名字叫“太过分了”，内容描述的就是如何识别什么情况是把一个好东西做得过了火。

&emsp;&emsp;本书中几乎所有的例子都是使用的Java或者C++，而大多数的讨论也是有关面向对象语言class的设计。然而，这些思路在其他领域也是适用的。几乎所有这些方法思路都可以应用在没有面向对象特性语言的函数里，比如C语言。这些设计思路也可以应用到其他非class的模块中，比如子系统或者网络服务。

&emsp;&emsp;在这个背景下，让我们详细讨论一下是什么导致了复杂性，又如何让软件系统变得更简单。