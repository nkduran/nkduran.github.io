---
title: 软件设计的哲学（一）
date: 2020-01-31 20:41:48
tags:
 - 软件设计
---

> 翻译自[《A Philosophy of Software Design》](https://book.douban.com/subject/30218046/)，作者[John Ousterhout](https://en.wikipedia.org/wiki/John_Ousterhout)，Tcl脚本语言和Tk工具库的发明人。

## <center>前言</center>

&emsp;&emsp;人们为电子计算机写程序已经有80多年的历史，但令人惊讶的是关于“如何设计程序”，或者“好的程序应该是什么样子”的讨论很少。有很多重要的讨论都是和诸如敏捷开发等软件开发流程，或者调试器、版本管理系统、测试覆盖工具这样的开发工具相关的。还有一些复杂分析是关于面向对象编程、函数式编程等编程技术，或者设计模式及算法的。所有这些讨论都是有价值的，但涉及到软件设计的核心问题始终没有被真正触碰到。David Parnas的经典论文《用于将系统分解成模块的准则》（On the Criteria to be used in Decomposing Systems into Modules）发布于1971年，而在随后的45年里，软件设计的技术水平相比这篇论文并没有多大进步。

&emsp;&emsp;计算机科学里最基础的问题就是***问题分解***：如何将一个复杂的问题分割成一些能够独立解决的小问题。问题分解是程序员每天需要面对的核心设计任务，而不是描述的所谓那些工作。我还没有在任何一所大学的单独课程里看到把问题分解作为核心论题的。课堂上我们只是在教循环或者面向对象编程，而不是软件设计。

&emsp;&emsp;另一方面，不同程序员间的生产力和产出质量存在着巨大差异。在研究是什么让最好的程序员如此优秀，或者在课程上讲授相关技术方面，我们并没有做出任何尝试。我和一些我认为是伟大的程序员的人聊过，他们中的大多数人都很难清晰地说出是哪些具体的技术给他们带来了优势。许多人都认为软件设计技术是与生俱来的天赋，是无法教授的。然而，有许多科学证据表明，很多领域中杰出的表现都和高质量的练习相关，而不是先天的能力。（有关内容可以参考Geoff Colvin的 ***《Talent is Overrated》*** 一书）

&emsp;&emsp;很多年来，这些问题都让我感到困惑和沮丧。我想知道软件设计能否被教授，我猜测设计能力是区分优秀程序员和平庸程序员的关键，最终我决定试着教授一门有关软件设计的课程，我认为这是获取这些问题答案的唯一方法。这就是斯坦福大学CS190课程的来历。在这门课上，我提出了一系列有关软件设计的原则，学生则通过完成一系列实际的项目来练习并掌握这些原则。这门课是以类似于传统英文写作课的方式进行讲授的。在英文课上，学生们会使用一种”拟稿-获取反馈-重写“这样的迭代过程来完成效果改进的。而在CS190中，学生们是从零开始开发一款复杂的软件，随后我们采用大量的代码审查以确定其中的设计问题，学生则修改他们的项目代码来解决这些问题。这个过程会让学生看到如何通过应用设计原则来改进他们的代码。

&emsp;&emsp;至今为止软件设计课程我教过三遍，而本书就是基于课程里所提炼出的设计原则写成的。这些原则是从相当高的层面来思考的，接近于编程哲学（比如“定义不存在的错误”）。对学生来讲这些抽象的想法很难理解，他们更多地是通过编写代码，犯错误，然后根据他们所犯的错误和随后的修复来分析如何与设计原则相关，而获得最佳的学习效果。

&emsp;&emsp;这时候你可能很想知道：是什么让我自以为知道所有有关软件设计的答案？坦白的说，我也不知道。在我学习编程的时代还没有任何有关软件设计的课程，也没有任何一位导师教给过我有关设计的原则。而在那个时代，代码评审也基本不存在。我关于软件设计的所有想法都来自于我个人读写代码这样的实践经验。在我整个职业生涯中，我使用不同语言写了大概有250000行代码。我在很多团队工作过，这些团队曾经从头开始编写了三款操作系统，开发了多文件及存储系统、调试器这样的基础工具、编译系统、GUI工具包、一种脚本语言，用于文本、绘图和演示的交互式编辑器以及集成电路等等。这样一路走来，我亲身体验了开发大型系统所遇到的各类问题，并尝试了各种设计技术。此外，我读过其他人写的相当多的代码，让我接触到了各种各样的方法，有好的也有坏的。

&emsp;&emsp;通过这些经验，我试着找出了一些通用的线索，既包括了要避免的错误，也包括了要使用的技术。这本书就是有关我经验的总结：其中每个描述的问题我个人都曾经历过，每个推荐的技术也都是曾经在我自己的代码中成功应用过的。

&emsp;&emsp;我并不期望这本书能给出软件设计的最终答案。我确信我错过了一些有价值的技术，而从长远来看，我的一些建议可能会变成糟糕的主意。然而，我希望本书可以引发一场关于软件设计的讨论。我建议把书里的想法和你自己的经验做比较，你自己来判断这里描述的方法是否真的降低了软件复杂性。这本书里阐述了很多我个人的观点，可能有的读者会反对我的一些建议。如果你不同意它，就试着去理解它。我感兴趣的是那些对你有用的或者没用的东西，以及你对软件设计的其他任何想法。我希望后续的讨论会改进我们对软件设计的整体理解。我会把讨论中学到的新东西写进这本书的未来版本里。

&emsp;&emsp;和我沟通这本书的最好方式是发邮件到以下地址：***software-design-book@googlegroups.com***。我很想听听针对这本书的具体反馈，像问题或者改进建议一类的，还有和软件设计相关的一般想法和经验。另外我也很想看到一些非常令人信服的例子，能够加入到本书未来的版本中。最好的例子就是用一到两段话给出足够简单的解释，来阐明一个重要的设计原则。如果你想要看看其他人在邮件里说了什么，并想参与到讨论中，可以加入Google Group ***software-design-book***。

&emsp;&emsp;如果未来因为某些原因Google Group ***software-design-book*** 不存在了，可以在网络上搜索我的个人主页。在主页上你可以找到关于本书如何交流的最新的指导信息。另外请不要发送和本书相关的邮件到我私人邮箱。

&emsp;&emsp;我建议你用批判的态度来看待书里的内容。软件设计的最终目标是降低复杂性，这比你读过的任何特定的原则或者想法都重要。如果你尝试了书中的一些想法最后发现实际上并没有降低复杂性，就不要觉得有义务再继续使用它。（一定要让我知道你的这些经历，我希望得到反馈，了解哪些可行，哪些不可行）

&emsp;&emsp;许多人提出了批评和建议，这些都有助于改进本书的质量。以下各位对本书的征求意见稿提出了有益的意见：Jeff Dean，Sanjay Ghemawat，John Hartman，Brian Kernighan，James Koppel，Amy Ousterhout，Kay Ousterhout，Rob Pike，Partha Ranganathan，Keith Schwartz和Alex Snaps。Christos Kozyrakis建议用术语“deep”和“shallow”来修饰类和接口，代替以前意义有些模糊的“thick”和“thin”。另外很感谢CS190课程上的学生们，通过阅读他们的代码并和他们进行讨论，帮助我更加明确了我有关设计的一些想法。